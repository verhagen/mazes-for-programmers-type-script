# Mazes for Programmers - Java Implementation - Progress


## The Basics

### Automating and Displaying Your Mazes

- [ ] Introducing Our Basic Grid
- [ ] Implementing the Grid Class
- [ ] Implementing the Binary Tree Algorithm
- [ ] Displaying a Maze on a Terminal
- [ ] Implementing the Sidewinder Algorithm
- [ ] Rendering a Maze as an Image


### Finding Solutions

- [ ] Implementing Dijkstra’s
- [ ] Finding the Shortest Path
- [ ] Making Challenging Mazes
- [ ] Coloring Your Mazes


### Avoiding Bias with Random Walks

- [ ] Implementing Aldous-Broder
- [ ] Implementing Wilson’s Algorithm


### Adding Constraints to Random Walks

- [ ] Implementing Hunt-and-Kill
- [ ] Counting Dead Ends
- [ ] Implementing the Recursive Backtracker


## Next Steps

### Fitting Mazes to Shapes


- [ ] Implementing a Mask
- [ ] ASCII Masks
- [ ] Image Masks


### Going in Circles

- [ ] Drawing Polar Grids
- [ ] Implementing a Polar Grid


### Exploring Other Grids

- [ ] Implementing a Hex Grid
- [ ] Displaying a Hex Grid
- [ ] Implementing a Triangle Grid
- [ ] Displaying a Triangle Grid


### Braiding and Weaving Your Mazes

- [ ] Implementing a Cost-Aware Dijkstra’s Algorithm
- [ ] Introducing Weaves and Insets
- [ ] Implementing the OverCell Class
- [ ] Implementing the UnderCell Class
- [ ] Implementing the WeaveGrid Class


## More Algorithms

### Improving Your Weaving

- [ ] Implementing Randomized Kruskal’s Algorithm
- [ ] Implementing Better Weaving


### Growing With Prim’s

- [ ] Simplified Prim’s Algorithm
- [ ] True Prim’s Algorithm
- [ ] The Growing Tree Algorithm


### Combining, Dividing

- [ ] Implementing Eller’s Algorithm
- [ ] Implementing Recursive Division
- [ ] Making Rooms with Recursion


## Shapes and Surfaces

### Extending Mazes into Higher Dimensions

- [ ] Adding a Third Dimension
- [ ] Displaying a 3D Maze


### Bending and Folding Your Mazes

- [ ] Cylinder Mazes
- [ ] Cube Mazes
- [ ] Sphere Mazes
